<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[异步请求vue-resource与axios用法的详细比较]]></title>
    <url>%2F2019%2F01%2F21%2F%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82vue-resource%E4%B8%8Eaxios%E7%94%A8%E6%B3%95%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[安装12345678//vue-resourcenpm install vue-resource --savecnpm install vue-resource --save(淘宝镜像安装)//axiosnpm install axios --savecnpm install axios --save(淘宝镜像安装) 全局配置vue-resource 配置了全局默认设置后，在全局和组件的调用都不用带头部 例如：Vue.http.get(url).then() this.$http.get(url).then() 注意：配置了root后，url需是相对路径 1234Vue.http.options.root = ' http://sfabric.sm/api/';Vue.http.headers.common['Accept'] = 'application/json';Vue.http.headers.common['X-Requested-With'] = 'XMLHttpRequest';Vue.http.headers.common['Authorization'] = 'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOi' axios 配置了全局配置后，在全局和组件的调用都不用带头部 例如：Axios.get(url).then().catch() this.$http.get(url).then().catch() 注意：配置了baseURL后，url需是相对路径 1234Axios.defaults.baseURL = 'http://sfabric.sm/api/';Axios.defaults.headers.common['Accept'] = 'application/json';Axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';Axios.defaults.headers.common['Authorization'] = 'Bearer eyJ0eXAiOiJKV1QiLCJh’ 快捷方法和选项配置12345678910111213141516171819// vue-resourceget(url, [options])head(url, [options])delete(url, [options])jsonp(url, [options])post(url, [body], [options])put(url, [body], [options])patch(url, [body], [options])// axiosaxios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) 选项和配置解析vue-resource options 选项说明1234567891011url string 请求的目标URLbody Object, FormData, string 作为请求体发送的数据headers Object 作为请求头部发送的头部对象params Object 作为URL参数的参数对象method string HTTP方法 (例如GET，POST，...)timeout number 请求超时（单位：毫秒） (0表示永不超时)before function(request) 在请求发送之前修改请求的回调函数progress function(event) 用于处理上传进度的回调函数 ProgressEventcredentials boolean 是否需要出示用于跨站点请求的凭据emulateHTTP boolean 是否需要通过设置X-HTTP-Method-Override头部并且以传统POST方式发送PUT，PATCH和DELETE请求。emulateJSON boolean 设置请求体的类型为application/x-www-form-urlencoded axios config 配置说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&#123; // `url`是将用于请求的服务器URL url: '/user', // `method`是发出请求时使用的请求方法 method: 'get', // 默认 // `baseURL`将被添加到`url`前面，除非`url`是绝对的。 // 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。 baseURL: 'https://some-domain.com/api/', // `transformRequest`允许在请求数据发送到服务器之前对其进行更改 // 这只适用于请求方法'PUT'，'POST'和'PATCH' // 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream transformRequest: [function (data) &#123; // 做任何你想要的数据转换 return data; &#125;], // `transformResponse`允许在 then / catch之前对响应数据进行更改 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // `headers`是要发送的自定义 headers headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params`是要与请求一起发送的URL参数 // 必须是纯对象或URLSearchParams对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是一个可选的函数，负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data`是要作为请求主体发送的数据 // 仅适用于请求方法“PUT”，“POST”和“PATCH” // 当没有设置`transformRequest`时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream data: &#123; firstName: 'Fred' &#125;, // `timeout`指定请求超时之前的毫秒数。 // 如果请求的时间超过'timeout'，请求将被中止。 timeout: 1000, // `withCredentials`指示是否跨站点访问控制请求 // should be made using credentials withCredentials: false, // default // `adapter'允许自定义处理请求，这使得测试更容易。 // 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api）） adapter: function (config) &#123; /* ... */ &#125;, // `auth'表示应该使用 HTTP 基本认证，并提供凭据。 // 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // “responseType”表示服务器将响应的数据类型 // 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default //`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress`允许处理上传的进度事件 onUploadProgress: function (progressEvent) &#123; // 使用本地 progress 事件做任何你想要做的 &#125;, // `onDownloadProgress`允许处理下载的进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength`定义允许的http响应内容的最大大小 maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise // HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。 // 如果设置为0，则不会遵循重定向。 maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。 // 允许配置类似`keepAlive`的选项， // 默认情况下不启用。 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy'定义代理服务器的主机名和端口 // `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。 // 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // “cancelToken”指定可用于取消请求的取消令牌 // (see Cancellation section below for details) cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 基本的http调用方式全局调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// vue-resource//vue-resource 在全局调用直接使用：get方法 get(url,[options])Vue.http.get(url).then(function(response)&#123; console.log(“成功的回调函数”)&#125;,function(error)&#123; console.log(“失败的回调函数”)&#125;)post方法post(url,[body],[options])Vue.http.post(url,orderObj).then(function(response)&#123; console.log(“成功的回调函数”)&#125;,function(error)&#123; console.log(“失败的回调函数”)&#125;)put方法put(url,[body],[options])Vue.http.put(url,orderObj).then(function(response)&#123; console.log(“成功的回调函数”)&#125;,function(error)&#123; console.log(“失败的回调函数”)&#125;)delete方法 delete(url,[options])Vue.http.delete(url).then(function(response)&#123; console.log(“成功的回调函数”)&#125;,function(error)&#123; console.log(“失败的回调函数”)&#125;)// axios 先在全局引入Axios://import Axios from ‘axios’get方法 get（url [，config]）Axios.get(url).then(function(response)&#123; console.log(“成功的回调函数”)&#125;).catch(function(error)&#123; console.log(“失败的回调函数”)&#125;)post方法 post（url [，data [，config]]）Axios.post(url,orderObj).then(function(response)&#123; console.log(“成功的回调函数”)&#125;).catch(function(error)&#123; console.log(“失败的回调函数”)&#125;)put方法 put（url [，data [，config]]）Axios.put(url,orderObj).then(function(response)&#123; console.log(“成功的回调函数”)&#125;).catch(function(error)&#123; console.log(“失败的回调函数”)&#125;)delete方法 delete（url [，config]）Axios.delete(url).then(function(response)&#123; console.log(“成功的回调函数”)&#125;).catch(function(error)&#123; console.log(“失败的回调函数”)&#125;) 组件实例调用123456789101112131415// vue-resourcethis.$http.get(url).then(function(response)&#123; console.log(“成功的回调函数”)&#125;,function(error)&#123; console.log(“失败的回调函数”)&#125;)// axiosthis.$http.get(url).then(function(response)&#123; console.log(“成功的回调函数”)&#125;).catch(function(error)&#123; console.log(“失败的回调函数”)&#125;) respose对象vue-resource response对象数据格式12345678910111213141516171819202122// vue-resource response对象数据格式1. body: 1. data:(10) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;] 2. message:"请求成功！" 3. moneysum:(2) [&#123;…&#125;, &#123;…&#125;] 4. quantitysum:[&#123;…&#125;] 5. total:107 6. __proto__:Object2. bodyText:"&#123;"message":"\u8bf7\u6c42\u6210\u529f\uff01","total":107,"moneysum":[&#123;"cur_code":"\u00a5 ","money":127381&#125;"3. headers:Headers 1. map:&#123;content-type: Array(1), cache-control: Array(1)&#125; 2. __proto__:Object4. ok:true5. status:2006. statusText:"OK"7. url:"http://sfabric.sm/api/sales-order?page=1&amp;per_page=10&amp;type=1,2"8. data:Object 1. data:(10) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;] 2. message:"请求成功！" 3. moneysum:(2) [&#123;…&#125;, &#123;…&#125;] 4. quantitysum:[&#123;…&#125;] 5. total:107 axios response 对象数据格式123456789101112131415161718192021221. config: 1. adapter:ƒ xhrAdapter(config) 2. baseURL:"http://sfabric.sm/api/" 3. data:undefined 4. headers:&#123;Accept: "application/json", X-Requested-With: "XMLHttpRequest", Authorization: "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI… dU12fxHarJv04UqlHahapT3vp4hWNXos_h2TQqzDyRfcQxOWY"&#125; 5. maxContentLength:-1 6. method:"get" 7. timeout:0 8. transformRequest:&#123;0: ƒ&#125; 9. transformResponse:&#123;0: ƒ&#125; 10. url:"http://sfabric.sm/api/sales-order?page=1&amp;per_page=10&amp;type=1,2" 11. validateStatus:ƒ validateStatus(status) 12. xsrfCookieName:"XSRF-TOKEN" 13. xsrfHeaderName:"X-XSRF-TOKEN" 14. __proto__:Object2. data:&#123;message: "请求成功！", total: 107, moneysum: Array(2), quantitysum: Array(1), data: Array(10)&#125;3. headers:&#123;content-type: "application/json", cache-control: "no-cache"&#125;4. request:XMLHttpRequest &#123;readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, onreadystatechange: ƒ, …&#125;5. status:2006. statusText:"OK" 拦截器vue-resource1234567891011121314151617181920212223242526272829303132//请求的处理Vue.http.interceptors.push(function(request, next) &#123; // modify method request.method = 'POST'; // modify headers request.headers.set('X-CSRF-TOKEN', 'TOKEN'); request.headers.set('Authorization', 'Bearer TOKEN'); // continue to next interceptor next();&#125;);//请求和响应的处理Vue.http.interceptors.push(function(request, next) &#123; // modify request request.method = 'POST'; // continue to next interceptor next(function(response) &#123; // modify response response.body = '...'; &#125;);&#125;);//返回一个响应并停止处理（？）Vue.http.interceptors.push(function(request, next) &#123; // modify request ... // stop and return response next(request.respondWith(body, &#123; status: 404, statusText: 'Not found' &#125;));&#125;);拦截器的使用，方便统一处理请求加头部，登录错误处理，响应错误处理 ，显示异步加载状态 axios1234567891011121314151617//请求拦截处理axios.interceptors.request.use(function (config) &#123; // Do something before request is sent return config; &#125;, function (error) &#123; // Do something with request error return Promise.reject(error); &#125;);// 响应拦截处理axios.interceptors.response.use(function (response) &#123; // Do something with response data return response; &#125;, function (error) &#123; // Do something with response error return Promise.reject(error); &#125;); 请求中断vue-resource123456789101112131415161718&#123; // GET /someUrl this.$http.get('/someUrl', &#123; // use before callback before(request) &#123; // abort previous request, if exists if (this.previousRequest) &#123; this.previousRequest.abort(); &#125; // set previous request on Vue instance this.previousRequest = request; &#125; &#125;).then(response =&gt; &#123; // success callback &#125;, response =&gt; &#123; // error callback &#125;);&#125; axios1234567891011121314151617181920212223242526272829303132你可以通过cancel token来取消一个请求使用CancelToken.source的工厂函数来创建一个cancel token:var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // handle error &#125;&#125;);// cancel the request (the message parameter is optional)source.cancel('Operation canceled by the user.');你也可以通过CancelToken的构造函数执行器来创建一个cancel tokenvar CancelToken = axios.CancelToken;var cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // An executor function receives a cancel function as a parameter cancel = c; &#125;)&#125;);// cancel the requestcancel();]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序自定义组件]]></title>
    <url>%2F2019%2F01%2F18%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、创建组件 wxml wxss js json 在js中 *1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Component/showToast/showToast.jsconst app = getApp();const &#123; requestData &#125; = require('../../utils/util');Component(&#123; //外部数据 从父组件传值 /** * 组件的属性列表 */ properties: &#123; isMask:&#123; // 最底层半透黑色遮罩显隐状态 type:Boolean, value:false &#125;, isnoIs:&#123; // 不能给自己投票 type: Boolean, value: false &#125;, isShut: &#123; // 是否确认投票 type: Boolean, value: false &#125;, isjorn: &#123; // 参与过了 type: Boolean, value: false &#125;, tpNameSplit: &#123; type: String, value: "" &#125;, name: &#123; // 被投票人姓名 type: String, value: "" &#125; &#125;, /** * 组件的初始数据 */ data: &#123; //内部数据 初始化渲染 &#125;, /** * 组件的方法列表 */ methods: &#123; hideToast:function()&#123; //关闭所有弹窗 清除数据 this.setData(&#123; isMask: false, isnoIs: false, isShut: false, isjorn: false, tpNameSplit: '', name: '' &#125;) &#125;&#125;) 2、引入组件123456&#123; "usingComponents": &#123; "showToast": "../../Component/showToast/showToast" //引入组件 &#125;, "enablePullDownRefresh": true&#125; 3、父组件向子组件传参 在index.wxml中： 1234567&lt;showToast id='showToast' isMask = '&#123;&#123;componentShowToast.isMask&#125;&#125;' isnoIs='&#123;&#123;componentShowToast.isnoIs&#125;&#125;' isShut='&#123;&#123;componentShowToast.isShut&#125;&#125;' isjorn='&#123;&#123;componentShowToast.isjorn&#125;&#125;' name='&#123;&#123;componentShowToast.name&#125;&#125;' tpNameSplit='&#123;&#123;componentShowToast.tpNameSplit&#125;&#125;'&gt;&lt;/showToast&gt; 在index.js中：12345678910data&#123; componentShowToast: &#123; isMask: false, isnoIs: false, isShut: false, isjorn: false, tpNameSplit: '', name:'' &#125;&#125; 显而易见 我们通过子组件的properties进行通信了 （见标题1）]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的MySQL驱动模板和mysql-connector-java.8.0.12]]></title>
    <url>%2F2019%2F01%2F15%2F%E6%96%B0%E7%9A%84MySQL%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%9D%BF%E5%92%8Cmysql-connector-java-8-0-12%2F</url>
    <content type="text"><![CDATA[新的MySQL驱动之前链接本地数据库用了一个5.X版本的：如图 我的数据库版本 如图： run之后；一直报了一个链接不了数据库的错误，一番操作之后启用了8.X的版本；运行之后如图 ： 运行成功 mysql-connector-java.8.0.12本版下载 [https://pan.baidu.com/s/16ZkrIpEIrALBNfokx2BXsw：https://pan.baidu.com/s/16ZkrIpEIrALBNfokx2BXsw “百度盘”) 百度盘密码 vt9o 主程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */package javaapplication4;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Arrays;import java.sql.PreparedStatement;/** * * @author zhang */public class JavaApplication4 &#123; static String selectsql = null; static ResultSet retsult = null; public static final String url = "jdbc:mysql://localhost:3306/intnation"; public static final String name = "com.mysql.jdbc.Driver"; public static final String user = "root"; public static final String password = "xxxx"; public static Connection conn = null; public static PreparedStatement pst = null; /** * @param args the command line arguments */ public static void main(String[] args) &#123; int paraCount = 5; //读取参数数量 selectsql = "select * from tb_emp";//SQL语句 try &#123; Class.forName(name);//指定连接类型 conn = DriverManager.getConnection(url, user, password);//获取连接 pst = conn.prepareStatement(selectsql);//准备执行语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; String [] paras = new String [paraCount]; try &#123; retsult = pst.executeQuery();//执行语句，得到结果集 while (retsult.next()) &#123; for(int i = 0;i&lt;paraCount;i++)&#123; paras[i] = retsult.getString(i+2); &#125; System.out.println(Arrays.toString(paras)); &#125;//显示数据 retsult.close(); conn.close();//关闭连接 pst.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序-图片宽100%显示不变形]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%9B%BE%E7%89%87%E5%AE%BD100-%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%8F%98%E5%BD%A2-1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[微信小程序-图片宽100%显示不变形]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%9B%BE%E7%89%87%E5%AE%BD100-%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%8F%98%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[mode 属性使用mode属性 属性值设置为widthFix ：宽度不变，高度自动变化，保持原图宽高比不变。 1&lt;image class='manImg' mode='widthFix' style="width:100%;" src='&#123;&#123;item.starItem.imageUrl&#125;&#125;' /&gt; bindLoad函数使用bindload绑定函数动态自适应。 当图片发布完毕时，调用这个函数实现动态自适应 12345678910111213141516//wxml&lt;image class='manImg' bindload="imageLoad" style="width:&#123;&#123;imgwidth&#125;&#125;rpx; height:&#123;&#123;imgheight &#125;&#125;rpx;" src='&#123;&#123;item.starItem.imageUrl&#125;&#125;' /&gt;//jsimageLoad: function(e) &#123; let _this=this; let width=e.detail.width, //获取图片真实宽度 height=e.detail.height, ratio=width/height; //图片的真实宽高比例 let viewWidth=500, //设置图片显示宽度， viewHeight=500/ratio; //计算的高度值 this.setData(&#123; imgwidth:viewWidth, imgheight:viewHeight &#125;)&#125; 推荐第一种：原因： 第二种实现方式每次图片发布完毕时都会执行一次通信（setData），营销页面渲染效率。第一种方式的优点在于 当宽度设置百分比100%时，宽度自然会自适应。换一种思路完全可以用外层的view去控制图片]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序下拉刷新]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[微信小程序下拉刷新设置json配置 这个配置可以设置在app.json里面 或者 单页面 json 里面 ， 意思就是开始下拉刷新 1"enablePullDownRefresh": true onPullDownRefresh事件监听下拉动作处理函数如下 1234/*** 页面相关事件处理函数--监听用户下拉动作*/onPullDownRefresh: function () &#123;&#125; 应用实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546onPullDownRefresh: function () &#123; wx.setNavigationBarTitle(&#123; //在标题栏中显示加载提示语 title: '加载中' &#125;); wx.showNavigationBarLoading(); //在标题栏中显示加载图标 // 第一种处理方式 计时器结束加载动画 // setTimeout(function()&#123; wx.hideNavigationBarLoading(); //完成停止加载 // 动态设置导航条标题 wx.setNavigationBarTitle(&#123; title: 'Mascent' &#125;); wx.stopPullDownRefresh(); //停止下拉刷新 &#125;,800) // 第二种处理方式 HTTP请求完成时结束加载动画 // // 发送请求 wx.request(&#123; url: url, data: &#123; user_id: user_id, &#125;, method: 'POST', //请求成功的函数处理 success: function (res) &#123; app.globalData.balance = res.data.data.balance; //对数据进行更新 that.setData(&#123; balance: app.globalData.balance, &#125;); &#125;, fail: function (res) &#123; //请求失败的处理 console.log(res.data.msg); &#125;, complete: function () &#123; wx.hideNavigationBarLoading(); //完成停止加载 // 动态设置导航条标题 wx.setNavigationBarTitle(&#123; title: 'Mascent' &#125;); wx.stopPullDownRefresh(); //停止下拉刷新 &#125; &#125;)&#125;,]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不显示]]></title>
    <url>%2F2019%2F01%2F07%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9C%9F%E6%9C%BAshowToast%E4%B8%8D%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[showToast闪烁做了一套公司的小程序，真机测试的时候发现一个问题 showToast闪烁一下 就消失了。然后我首先想到的是 是不是hide了。然后去复检代码，结果如下： 从头开始捋一下执行的顺序就不难理解了，代码顺序 wx.showLoading() =&gt;wx.hideLoading() =&gt; wx.showToast() ， 最后的运行顺序为wx.showLoading() =&gt; wx.showToast() =&gt;wx.hideLoading() ，受到最后hide的影响，闪烁一下就没了。既然问题找到，解决就不难了 思路 先执行hide 把showToast拿到最后去执行 *1234567891011wx.showLoading();wx.hideLoading();setTimeout( () =&gt; &#123; wx.showToast(&#123; title: '提示语', icon: "none", &#125;); setTimeout( () =&gt;&#123; wx.hideToast(); &#125;,2000)&#125;,0); 错误代码12345678910111213141516171819202122232425// 请求事件requestEvent: function() &#123; wx.showLoading(&#123; title: '正在加载中', &#125;) wx.request(&#123; url: '', success: function(res) &#123; wx.showToast(&#123; title: '成功', duration: 2000 &#125;) &#125;, fail: function() &#123; wx.showToast(&#123; title: '失败', duration: 2000 &#125;) &#125;, complete: function() &#123; wx.hideLoading() //***** 问题出在这儿 调用 onComplete 时，hideLoading 将弹框隐藏掉了 &#125; &#125;)&#125; 正确代码123456789101112131415161718192021222324// 请求事件requestEvent: function() &#123; wx.showLoading(&#123; title: '正在加载中', &#125;) wx.request(&#123; url: '', success: function(res) &#123; wx.hideLoading() wx.showToast(&#123; title: '成功', duration: 2000 &#125;) &#125;, fail: function() &#123; wx.hideLoading() wx.showToast(&#123; title: '失败', duration: 2000 &#125;) &#125; &#125;)&#125;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序之页面声明周期]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%A1%B5%E9%9D%A2%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[微信小程序的页面声明周期12345678910111213141516onLoad: 页面加载 一个页面只会调用一次。 接收页面参数 可以获取wx.navigateTo和wx.redirectTo及&lt;navigator/&gt;中的 query。onShow: 页面显示 每次打开页面都会调用一次。onReady: 页面初次渲染完成 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。onHide: 页面隐藏 当navigateTo或底部tab切换时调用。onUnload: 页面卸载 当redirectTo或navigateBack的时候调用。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序之属性值为Boolean的绑定问题]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%80%BC%E4%B8%BABoolean%E7%9A%84%E7%BB%91%E5%AE%9A%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[微信小程序的属性为Boolean类型的时候遇到的一些问题之前看好多人发的博客 感觉还是抄袭的居多 示例如下12345// 好多博客都是这么写的&lt;form class='form' bindsubmit="formSubmit" report-submit = 'true'&gt;// 查看编译之后的结构发现 这么写编译之后 执行的是字符串 引号之后 true 或者 false 都是一样的不起作用report-submit = 'true' → report-submit = ''//发现问题了吗 朋友们 正确的写法1234567891011//wxml&lt;form class='form' bindsubmit="formSubmit" report-submit = '&#123;&#123;getFormId&#125;&#125;'&gt;// jsPage(&#123; /** * 页面的初始数据 */ data: &#123; getFormId:true &#125; 遇到问题一定要自己去实践 实践得真知 *]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序组件之picker]]></title>
    <url>%2F2018%2F12%2F29%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E4%B9%8Bpicker%2F</url>
    <content type="text"><![CDATA[picker 之 日期 闲话不多说 直接拍代码 * 12345678910111213141516//wxml// fields 是精细度 可以是 年 或 月 或 日&lt;picker mode="date" value="&#123;&#123;date&#125;&#125;" fields="month" bindchange="bindDateChange"&gt;&lt;view class="picker"&gt;&#123;&#123;date&#125;&#125;&lt;/view&gt;&lt;/picker&gt;// jsdate: '2016-09',bindDateChange(e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value)&#125;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>picker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序onLaunch的异步问题解决方案]]></title>
    <url>%2F2018%2F12%2F29%2F%E5%B0%8F%E7%A8%8B%E5%BA%8FonLaunch%E7%9A%84%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[微信小程序app.js 中 onLaunch 与 index.js 中 onload 的异步执行问题 ， 在同时触发的情况下 如何等待返回值而响应index中 onload的内容 比如说 获取用户的openid或者凭证 在没返回需要的数据之前 index.js 的 onload会执行 从而导致后续的代码没有openid的支持 * ES6中提供了一个promise方案是一个不错的解决方案先做一个示例说明一下promise的用法Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。1234567891011121314function runAsync()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('执行完成'); resolve('随便什么数据'); &#125;, 2000); &#125;); return p;&#125;// 如何用？runAsync(function(data)&#123; console.log(data);&#125;); reject的用法我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。123456789101112131415161718192021222324252627function getNumber()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=5)&#123; resolve(num); &#125; else&#123; reject('数字太大了'); &#125; &#125;, 2000); &#125;); return p;&#125;getNumber().then( function(data)&#123; console.log('resolved'); console.log(data); &#125;, function(reason, data)&#123; console.log('rejected'); console.log(reason); &#125;); 将promise结合到小程序中promise下载地址promiseCND 将压缩版本的源码直接复制出来 在小程序中创建一个promise.js的文件 直接粘贴进去 然后在app.js中引用 1const Promise = require('utils/promise.js'); APP.js 中的代码 将你本来写在 onLaunch 中的代码片段拿出来 重新写一个方法* 123456789101112131415161718192021222324252627282930313233343536login:function()&#123; let that = this; return new Promise(function (resolve, reject) &#123; // 登录 wx.login(&#123; success: res =&gt; &#123; // 发送 res.code 到后台换取 openId, sessionKey, unionId if (res.code) &#123; // console.log('获取用户登录凭证：' + code); // ------ 发送凭证 ------ /* * 通过code获取登录session */ wx.request(&#123; url: 'xxx/login?code=' + res.code, method: 'GET', header: &#123; 'content-type': 'application/json' &#125;, success: function (res) &#123; console.log(res) if (res.statusCode == 200) &#123; // 注意这里 resolve(res); &#125; else &#123; console.log(res.errMsg) &#125; &#125;, &#125;) &#125; else &#123; console.log('获取用户登录失败：' + res.errMsg); &#125; &#125; &#125;) &#125;) &#125; index.js 中的代码12345678910const &#123; requestData &#125; = require('../../utils/util');onLoad: function (options) &#123; let _this = this; app.login().then(function (res) &#123; let newDate = new Date(); // 修改到当前的时间 _this.changeNowTime(); &#125;)&#125;,]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>onLaunch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序项目request请求优化]]></title>
    <url>%2F2018%2F12%2F24%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%8F%91%E8%B5%B7request%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[这是微信小程序官网API列表里面 wx.request(OBJECT)官方示例1234567891011121314wx.request(&#123; url: 'xxxx.php', data: &#123; x: '' , y: '' &#125;, method:"POST", header: &#123; 'content-type': 'application/json' &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) 参数说明 参数名 类型 必填 默认值 说明 url String 是 开发者服务器接口地址 data Object/String/ArrayBuffer 否 请求的参数 header Object 否 设置请求的 header，header 中不能设置 Referer。 method String 否 GET 有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT dataType String 否 json 如果设为json，会尝试对返回的数据做一次 JSON.parse responseType String 否 text 设置响应的数据类型。合法值：text、arraybuffer success Function 否 收到开发者服务成功返回的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 优雅的封装我写在了page的同级目录utils下的utils.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134const requestData = &#123; /** * url = String 请求地址 * obj = Object 请求参数 * success = function 成功回调 * fail = function 成功回调 */ get: (url, data, success, fail) =&gt; &#123; if ((typeof data) == 'function') &#123; if (success &amp;&amp; (typeof success) == 'function') &#123; fail = success; &#125; success = data; data = ''; console.log(success, data, fail) &#125; wx.request(&#123; url: url, data: data || '', header: &#123;&#125;, method: 'GET', dataType: 'json', responseType: 'text', success(res) &#123; if (success) &#123; success(res); &#125; &#125;, fail(res) &#123; if (fail) &#123; fail(res); &#125; wx.hideLoading(); wx.showToast(&#123; title: '请求超时', icon: 'loading', duration: 2000 &#125;) &#125;, complete: function () &#123; wx.hideLoading(); &#125; &#125;) &#125;, post: (url, data, success, fail) =&gt; &#123; if ((typeof data) == 'function') &#123; if (success &amp;&amp; (typeof success) == 'function') &#123; fail = success; &#125; success = data; data = ''; console.log(success, data, fail) &#125; wx.request(&#123; url: baseUrl + url, data: data || '', header: &#123;&#125;, method: 'POST', dataType: 'json', responseType: 'text', success(res) &#123; if (success) &#123; success(res); &#125; &#125;, fail(res) &#123; if (fail) &#123; fail(res); &#125; &#125; &#125;) &#125;, del: (url, data, success, fail) =&gt; &#123; if ((typeof data) == 'function') &#123; if (success &amp;&amp; (typeof success) == 'function') &#123; fail = success; &#125; success = data; data = ''; console.log(success, data, fail) &#125; wx.request(&#123; url: baseUrl + url, data: data || '', header: &#123;&#125;, method: 'DELETE', dataType: 'json', responseType: 'text', success(res) &#123; if (success) &#123; success(res); &#125; &#125;, fail(res) &#123; if (fail) &#123; fail(res); &#125; &#125; &#125;) &#125;, put: (url, data, success, fail) =&gt; &#123; if ((typeof data) == 'function') &#123; if (success &amp;&amp; (typeof success) == 'function') &#123; fail = success; &#125; success = data; data = ''; console.log(success, data, fail) &#125; wx.request(&#123; url: baseUrl + url, data: data || '', header: &#123;&#125;, method: 'PUT', dataType: 'json', responseType: 'text', success(res) &#123; if (success) &#123; success(res); &#125; &#125;, fail(res) &#123; if (fail) &#123; fail(res); &#125; &#125; &#125;) &#125;&#125;module.exports = &#123; requestData: requestData&#125; 封装之后的使用在js的代码示例 123456789101112131415// 一定记得先引入const &#123;requestData&#125; = require('../../utils/util');requestData.get('你的请求URL', res =&gt; &#123; if (res.statusCode == 200) &#123; console.log(res) this.setData(&#123; hotList: res.data.body &#125;); &#125; else &#123; console.log(res.errMsg) &#125;&#125;, err =&gt; &#123; console.log(err)&#125;)]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript骚操作之操作符]]></title>
    <url>%2F2018%2F12%2F23%2FJavaScript%E9%AA%9A%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[三目运算符 ?:12345if (hasMoney) &#123; console.log('周末嗨翻天');&#125; else &#123; console.log('周末睡一天');&#125; 1hasMoney ? console.log('周末嗨翻天') : console.log('周末睡一天'); 1let weekendPlan = hasMoney ? '周末嗨翻天' : '周末睡一天'; 逻辑与操作符 &amp;&amp;123if (hasMoney) &#123; console.log('周末嗨翻天');&#125; 1hasMoney ? console.log('周末嗨翻天') : undefined; 1hasMoney &amp;&amp; console.log('周末嗨翻天'); 12345true &amp;&amp; console.log('It is true'); // It is truetrue &amp;&amp; false &amp;&amp; console.log('It is true'); // 返回 falsetrue &amp;&amp; 0 &amp;&amp; console.log('It is true'); // 返回 0true &amp;&amp; undefined == null &amp;&amp; console.log('It is true'); // It is true, 表达式undefined == null的运算结果为truetrue &amp;&amp; undefined === null &amp;&amp; console.log('It is true'); // 返回 false, 表达式undefined === null的运算结果为false 逻辑或操作符 ||12// 当自身为undefined时，赋值为0，否则还是赋值为自身 val = val !== undefined ? val : 0; 1val = val || 0; 1234567891011121314// ES5设置函数默认值 function testFunc(arg1) &#123; arg1 = arg1 || 1; // do something else &#125; let a = 1, b = 2, c = null; console.log(a || b || c); // 1 console.log(0 || b || c); // 2 console.log(0 || false || c); // null 按位取反操作符 ~123let arr = ['we', 'are', 'the', 'BlackGold', 'team'];arr.includes('the') &amp;&amp; console.log('in'); // in 123let arr = ['we', 'are', 'the', 'BlackGold', 'team'];arr.includes(element =&gt; element === 'the') &amp;&amp; console.log('in'); // 返回false 123let arr = ['we', 'are', 'the', 'BlackGold', 'team'];arr.findIndex(element =&gt; element === 'the') !== -1 &amp;&amp; console.log('in'); // in 1234let arr = ['we', 'are', 'the', 'BlackGold', 'team'];~arr.findIndex(element =&gt; element === 'we') &amp;&amp; console.log('in'); // in~arr.findIndex(element =&gt; element === 'the') &amp;&amp; console.log('in'); // in 123console.log(~-1); // 0 转换为Boolean值即为falseconsole.log(~0); // -1 转换为Boolean值即为trueconsole.log(~1); // -2 转换为Boolean值即为true]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序页面跳转传值和取值]]></title>
    <url>%2F2018%2F12%2F21%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E4%BC%A0%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%2F</url>
    <content type="text"><![CDATA[跳转传值 先看数据传递 * 1&lt;radio class='clickeds' value="&#123;&#123;item&#125;&#125;***&#123;&#123;index&#125;&#125;***&#123;&#123;hotList[index].id&#125;&#125;" checked="&#123;&#123;item.checked&#125;&#125;"/&gt; 12345678radioChange: function (e) &#123; console.log('radio发生change事件，携带value值为：', e.detail.value) this.checkCard = e.detail.value; var that = this; that.setData(&#123; botCardPrize: e.detail.value.split("&amp;")[0] &#125;);&#125;, 12345topay:function()&#123; var that = this; console.log( "选中的会员卡金额为: " + that.data.botCardPrize); wx.navigateTo(&#123; url: "../../pages/buyCard/buyCard?price=" + this.checkCard.split("&amp;")[0] + "&amp;name=" + this.checkCard.split("&amp;")[1] + "&amp;productId=" + this.checkCard.split("&amp;")[2] + "&amp;type=" + this.giftCard &#125;) &#125; 在这里radio先选中，然后赋值给data中的checkCard，然后点击付款按钮的时候进行传值并且跳转到付款页 在新页面接收数据12345678910111213onLoad: function (options) &#123; let thisPrice = options.price*100; let productName = options.name; let id = options.productId; let type = options.type; let toPay = &#123; thisPrice: thisPrice, productName: productName, id: id, type: type &#125;; this.payInfo = toPay; &#125;, option后面跟链接中的对应键解出值，组合成新的数据对象]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序下方滑出弹窗css解决方案]]></title>
    <url>%2F2018%2F12%2F21%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8B%E6%96%B9%E6%BB%91%E5%87%BA%E5%BC%B9%E7%AA%97css%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[用css解决小程序点击按钮下方滑出弹窗用@keyframes完成动画效果12345678910111213141516.up&#123; animation: up .7s;&#125;.down&#123; animation: down 1s;&#125;@keyframes up&#123; 0% &#123; transform: translateY(550rpx); &#125; 100% &#123; transform: translateY(0); &#125;&#125;@keyframes down&#123; 0% &#123; transform: translateY(0); &#125; 100% &#123; transform: translateY(550rpx); &#125;&#125; 绑定class12345678910111213&lt;!-- 立即预约 --&gt;&lt;view wx:if="&#123;&#123;disTag&#125;&#125;" class='order'&gt; &lt;view class="order-box &#123;&#123;disTag== true ? 'up' : 'down'&#125;&#125;"&gt; //绑定class完成加载效果 &lt;icon class='clear' type="clear" size="20" bindtap='clear'/&gt; &lt;view class='pro shop-prize'&gt; 门市价格：&lt;text style=''&gt;￥199&lt;/text&gt; &lt;/view&gt; &lt;view class='pro order-prize'&gt; 支付金额：&lt;text&gt;￥&#123;&#123;yyPrice&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;button class='yd-submit' bindtap='payNow'&gt;立即支付&lt;/button&gt; &lt;/view&gt;&lt;/view&gt;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular中使用a标签的锚点]]></title>
    <url>%2F2018%2F12%2F19%2Fangular%E4%B8%AD%E4%BD%BF%E7%94%A8a%E6%A0%87%E7%AD%BE%E7%9A%84%E9%94%9A%E7%82%B9%2F</url>
    <content type="text"><![CDATA[在ng中，a标签中的href属性会自动的使用路由机制，最后的结果会被当成跳转的路由地址，具体的原因有待进一步考证，反正最后的结果就是上面的写法不生效。 普通页面中的写法 12&lt;a href="#test"&gt;走你&lt;/a&gt;&lt;div id="test"&gt;被定位区域&lt;/div&gt; angular中锚点写法 12&lt;a router="./" [fragment]="test"&gt;来吧&lt;/a&gt;&lt;div id="test"&gt;被定位区域&lt;/div&gt;]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>锚点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE组件开发-props验证]]></title>
    <url>%2F2018%2F12%2F19%2FVUE%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91-props%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[为什么要有props验证 在Vue中父组件向子组件中传送数据是通过props实现的，想象一下当有一个人要使用foo-component组件的时候，他可能对于其要接受的参数有什么要求并不是很清楚，因此传入的参数可能会在开发子组件的人的意料之外，程序就会发生错误，就像我们在函数调用之前先检查一下函数一样，props也可以进行一个预先检查。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Vue Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;foo-component :foo-message="fooMessage"&gt;&lt;/foo-component&gt; &lt;/div&gt;&lt;script type="text/javascript" src="lib/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var fooComponent = &#123; props: &#123; fooMessage: Number &#125;, template: '&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;' &#125;; var vm = new Vue(&#123; components: &#123; 'foo-component': fooComponent &#125;, el: '#app', data: &#123; fooMessage: 123 &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以使用type来声明这个参数可以接受的数据的类型，当检查规则只有一个的时候type可以略写 如:fooMessage: Number 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Vue Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;foo-component :foo-message="fooMessage"&gt;&lt;/foo-component&gt; &lt;/div&gt;&lt;script type="text/javascript" src="lib/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var fooComponent = &#123; props: &#123; fooMessage: [Number, String] &#125;, template: '&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;' &#125;; var vm = new Vue(&#123; components: &#123; 'foo-component': fooComponent &#125;, el: '#app', data: &#123; fooMessage: 123 &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当参数可以是多种类型的其中一个的时候，使用数组来表示。 如 fooMessage: [Number, String] type能够指定的类型123456789101112131415type可以是以下原生类型：StringNumberBooleanFunctionObjectArraySymbol required可以使用required选项来声明这个参数是否必须传入。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Vue Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;foo-component :foo-message="fooMessage"&gt;&lt;/foo-component&gt; &lt;/div&gt;&lt;script type="text/javascript" src="lib/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var fooComponent = &#123; props: &#123; fooMessage: &#123; type: Number, required: true &#125; &#125;, template: '&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;' &#125;; var vm = new Vue(&#123; components: &#123; 'foo-component': fooComponent &#125;, el: '#app', data: &#123; fooMessage: 256 &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当未传入参数时：会抛出异常 default使用default选项来指定当父组件未传入参数时props变量的默认值： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Vue Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;foo-component&gt;&lt;/foo-component&gt; &lt;/div&gt;&lt;script type="text/javascript" src="lib/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var fooComponent = &#123; props: &#123; fooMessage: &#123; type: Number, default: 128 &#125; &#125;, template: '&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;' &#125;; var vm = new Vue(&#123; components: &#123; 'foo-component': fooComponent &#125;, el: '#app', data: &#123; fooMessage: 256 &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当type的类型为Array或者Object的时候default必须是一个函数：12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Vue Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;foo-component&gt;&lt;/foo-component&gt; &lt;/div&gt;&lt;script type="text/javascript" src="lib/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var fooComponent = &#123; props: &#123; fooMessage: &#123; type: Array, default: function()&#123; return ['foo', 'bar']; &#125; &#125; &#125;, template: '&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;' &#125;; var vm = new Vue(&#123; components: &#123; 'foo-component': fooComponent &#125;, el: '#app', data: &#123; fooMessage: ['f', 'o', 'o'] &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; validator 自定义当校验规则很复杂，默认提供的校验规则无法满足的时候可以使用自定义函数来校验。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Vue Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;foo-component :foo-message="fooMessage"&gt;&lt;/foo-component&gt; &lt;/div&gt;&lt;script type="text/javascript" src="lib/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var fooComponent = &#123; props: &#123; fooMessage: &#123; validator: function(value)&#123; return value&gt;=0 &amp;&amp; value&lt;=128; &#125; &#125; &#125;, template: '&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;' &#125;; var vm = new Vue(&#123; components: &#123; 'foo-component': fooComponent &#125;, el: '#app', data: &#123; fooMessage: 100 &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 综上所述123456789101112131415161718192021222324252627282930props: &#123; // fooA只接受数值类型的参数 fooA: Number, // fooB可以接受字符串和数值类型的参数 fooB: [String, Number], // fooC可以接受字符串类型的参数，并且这个参数必须传入 fooC: &#123; type: String, required: true &#125;, // fooD接受数值类型的参数，如果不传入的话默认就是100 fooD: &#123; type: Number, default: 100 &#125;, // fooE接受对象类型的参数 fooE: &#123; type: Object, // 当为对象类型设置默认值时必须使用函数返回 default: function()&#123; return &#123; message: 'Hello, world' &#125; &#125; &#125;, // fooF使用一个自定义的验证器 fooF: &#123; validator: function(value)&#123; return value&gt;=0 &amp;&amp; value&lt;=100; &#125; &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>props</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用哈希值匹配替换大量的if-else引用]]></title>
    <url>%2F2018%2F12%2F17%2F%E7%94%A8%E5%93%88%E5%B8%8C%E5%80%BC%E5%8C%B9%E9%85%8D%E6%9B%BF%E6%8D%A2%E5%A4%A7%E9%87%8F%E7%9A%84if-else%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[遇到需要写很多if…else…的情况，或许可以考虑如下的哈希字典匹配的方法，或者用状态模式实现需要修改的代码123456789//if...else...方法 /* var itemTypeStr = ''; if(rowdata.itemType == '1')&#123; itemTypeStr = '行政许可'; &#125;else if(rowdata.itemType == '2')&#123; itemTypeStr = '非行政许可'; &#125;else if(rowdata.itemType == '3')&#123; itemTypeStr = '公共服务事项'; &#125; */ 可以修改到下面的形式12345678910111213141516171819202122var itemTypeReg = &#123; '0':'', '1':'行政许可', '2':'非行政许可', '3':'公共服务事项', '4':'备案', '5':'其他', '6':'行政征收', '7':'行政确认', '8':'行政年检', '9':'其他行政权力', '10':'行政处罚', '11':'行政强制', '12':'行政给付', '13':'行政检查', '14':'行政奖励', '15':'行政裁决'&#125;var itemType = rowdata.itemType;//itemType为1~15的数，哈希匹配的方法，例子仅供参考itemType = itemTypeReg[itemType];return itemType;]]></content>
  </entry>
  <entry>
    <title><![CDATA[固定背景图片]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%9B%BA%E5%AE%9A%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[固定背景图片Div的背景图固定在视窗内（看似是固定于body） 无论滚动条上下如何滑动始终是固定的1234 background-repeat: no-repeat; background-size: cover; background-position: top; background-attachment: fixed; ****** 重要 fixed]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular中用js语言的问题]]></title>
    <url>%2F2018%2F12%2F17%2Fangular%E4%B8%AD%E7%94%A8js%E8%AF%AD%E8%A8%80%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天分享一下最近遇到的一个问题用 angular 前端框架为应用登录新增图形验证码认证，由于没有现成的插件，于是便使用canvas+js操作，也是可以正常使用，但是在编译阶段却有个报错：12ERROR in src/app/login/login.component.ts(84,19): error TS2339:Property 'getContext' does not exist on type 'HTMLElement'. 虽然报错，但是确实可以正常执行，很是奇怪。报错的代码为： 12let c = document.getElementById("myCanvas") ;let ctx = c.getContext("2d"); 查看源码是有 getContext() 这个方法的。后面想是不是类型导致的呢，于是，使用类型断言（不影响代码运行，只是在编译阶段起作用）修改代码入下： 12let c = document.getElementById("myCanvas") as HTMLCanvasElement;let ctx = c.getContext("2d"); 编译正常通过。后面了解，还有另外一种断言方式： 12let c = &lt;HTMLCanvasElement&gt; document.getElementById("myCanvas") ;let ctx = c.getContext("2d"); 以上均可编译通过，因为 getContext() 是在 HTMLCanvasElement 中定义的，因此，我们需要指定类型。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序切换主题配色]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E8%89%B2%2F</url>
    <content type="text"><![CDATA[相信大家一定会遇到小程序的主题配色问题，今天分享的内容主要就是如何根据自己的配置切换主题配色配图1、确定好需要修改的部分，配置主题123456789101112131415161718// 可以配置在app.js里面 也可以配置在外层框架 在这里我是配置在app.js然后全局储存了globalData: &#123; userInfo: null, // 主题配色配置 theme:&#123; //顶部配色 navigationBarColor:"#df4ecd", //图标配色 images:[ "../../images/addShop.png", "../../images/yuyue.png" ], // body 中含有亮粉的字体配色 ex: 产品活动价格 98 bodyFontColor:"#df4ecd", // 各个栏目标题配色 ex: 活动产品 人员推荐 等 titleColor:"#e67dd8" &#125;&#125; 现在主题配置一目了然，然后进行数据绑定，可以通过修改如上配置进行全局的主题修改 2、修改顶部主题NavigationBarColor配色wx.setNavigationBarColor 12345678wx.setNavigationBarColor(&#123; frontColor: '#ffffff', // 必写项 backgroundColor: app.globalData.theme.navigationBarColor, // 必写项 对应如上配置 animation: &#123; // 可选项 duration: 400, timingFunc: 'easeIn' &#125;&#125;) 3、绑定page中各个需要变化的在这里我做了 图片的切换 文字字体颜色的切换 12345678//page js 的配置Page(&#123; data: &#123; addImg:app.globalData.theme.images[0], yyImg: app.globalData.theme.images[1], fontColor: app.globalData.theme.bodyFontColor, titleColor: app.globalData.theme.titleColor &#125; 12345//wxml 的绑定&lt;view class='tabHeaderLine' style='background:&#123;&#123;fontColor&#125;&#125;'&gt;&lt;/view&gt;&lt;text style='color:&#123;&#123;titleColor&#125;&#125;'&gt;优惠券领取&lt;/text&gt;&lt;image class='addShop' src='&#123;&#123;addImg&#125;&#125;' /&gt;&lt;image class='yuyue' src='&#123;&#123;yyImg&#125;&#125;' /&gt; 绑定之后 就可以试一下了 修改最上面的配置进行小程序的主题配色替换吧 哦 对了 如果有需要替换tabBar的配色的 可以根据小程序官方API就行替换 很详细的]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inputFile上传图片并显示]]></title>
    <url>%2F2018%2F12%2F17%2FinputFile%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[input 上传图片 并将上传的图片加载显示闲话不多说 直接撸代码HTML部分12&lt;img id="gzzImg" src="images/common/add.png" /&gt;&lt;input id="gzzIpt" class="fileIpt" type="file" onchange="loadImg()"/&gt; js部分123456789101112131415161718192021function loadImg()&#123; //获取文件 var file =document.getElementById("gzzIpt").files[0]; //创建读取文件的对象 var reader = new FileReader(); //创建文件读取相关的变量 var imgFile; //为文件读取成功设置事件 reader.onload=function(e) &#123;// alert('文件读取完成'); imgFile = e.target.result; console.log(imgFile); $("#gzzImg").attr('src', imgFile); &#125;; //正式读取文件 reader.readAsDataURL(file);&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烦人的广告]]></title>
    <url>%2F2018%2F12%2F14%2F%E7%83%A6%E4%BA%BA%E7%9A%84%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[让烦人的广告滚出我们的界面-码农的路上，纵情向前！ 1-现像最近越来越多的用户向客服反映，在使用我们的App过程中，会莫名其妙的在底部出现广告，甚至黄色信息。这些信息不但困扰了用户，影响用户的使用,最关键是使得用户散失对我们公司的信任,觉得我们公司的开发技术不行（什么？？？什么？技术不行？？出来，出来，我要和你大战三百回合、）。那么这个时候不仅仅是要给用户一个合理的解释，查出现象的原因，杜绝现象的再发生就显得迫不及待了。 2-原因当时接到用户反馈，我们第一时间对现象发生的原因进行了一系列猜想： 1.是不是我们项目中的第三方jar非官方版本，被植入了一些广告代码2.dns劫持3.http劫持做技术的都明白，那就是经验有的时候是助力，也是阻力。很多时候我们会被我们的经验所羁绊。很多资深技术，看到第一条的现象很容易冒出脑海的肯定是：劫持。那么第一条的理由是不是可能导致这种现象，从实现来说，完全可以做到的。现在很多开发人员平常开发过程随意之极，频繁的在项目使用一些小众且不规范的第三方jar包。而这些第三方jar也会是一些广告的来源。甚至是安全隐患的来源。 1.用的是4g还是wifi？2.如果是wifi，是不是路边免费的wifi？3.在什么页面出现？方便定位是h5页面还是原生界面，对大部分用户，千万不要问他是h5还是原生，只能自己分析，如果原生界面也出现那么第三方jar出现问题的概率很大，如果只是h5界面，那么劫持的可能性很大 4.使用的是Android 还是iOS客户端 综合用户的答案，我们总结如下：1.4g，wifi都出现了。2.出现的位置都是h5页面。3.android ios都出现了 3-排查那基本可以定位是网络劫持原因。那么网络劫持有2种 1.dns劫持2.http劫持什么是DNS劫持: 首先DNS是什么。在因特网中，机器相互识别靠的是ip，而ip单纯的无意义数字的结合，很难被人类熟记，所以产生了域名，例如www.baidu.com就是域名。那么问题来了，我们输入域名，机器又不认识，那么机器怎么去访问？那么就轮到DNS出场了，DNS在作为域名和IP地址相互映射的一个分布式数据库，就是我们的浏览器，会将域名拿到DNS去解析出ip地址来访问，DNS劫持是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。 通俗来说，就是他给我们指向了另一个地址，或者让我们无法访问。电信以前的互联星空的，每次联网打开的第一个网页永远是互联星空。就是典型的DNS劫持。 什么是http劫持: 百度百科的说法：HTTP劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的网络数据报文，目的是让用户端程序解释“错误”的数据，并以弹出新窗口的形式在使用者界面展示宣传性广告或者直接显示某网站的内容。 通俗来说，你要去百度的首页，他会给你百度首页，然后再百度首页的某个部位＋个广告。更具欺骗性，危害更大。（毕竟直接给你导向另外一个网址，用户也不是傻逼，上当的可能性很小。）而这也是现在很多免费wifi植入广告的手段，因为这样能更多的点击。 而很明显，我们遇到的是第二种 4-解决方案原因定位之后，就是制定解决方案了。根据这个http劫持的特性，我们可以很简单的给出解决方案: https。https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。就是说数据交流是加密的那么所谓的在返回数据里面加点广告就无从谈起了。而且https也能解决dns劫持（基本杜绝）。 那么我们需要一个临时解决方案。那么怎么解决呢。既然这些猥琐的劫持者通过插入一段js，那么不让他执行这段js就好了。因为android3.0以后webview提供了方法可以方便的拦截到所有的ajax请求，那么所有的js，图片下载都可以拦截到。我们可以做个区分，对要执行的js做一个筛选。 从API 11开始引入，API 21弃用@Override 1public WebResourceResponse shouldInterceptRequest(WebView view, String url) &#123; return Tool.getResponse(WebViewActivity.this,url,control); &#125; 从API 21开始引入 @Override 1public WebResourceResponse shouldInterceptRequest(WebView view, final WebResourceRequest request) &#123; return Tool.getResponse(WebViewActivity.this,request.getUrl().toString(),control); &#125; webview在WebViewClient里提供的2种拦截ajax请求的方法所有我们做了白名单和黑名单的机制，因为现在hybird的开发流行，app嵌入了很多h5，而h5页面的制作也参杂了很多第三方的jar，如果只是单纯的把公司域名下的请求之外的请求拦截，很容易导致h5的某些功能无法使用，所有我们采用了拦截开关的机制。在前2天上报非白名单的url，方便我们派出一些误伤的url，这样加入到白名单，以后开启拦截的开关，就能做到无误伤。（https才是正统的解决方案，拦截请求的局限性太大，而且很容易导致功能误伤）。 然后我拿着我开启了拦截开关的app，上了上海的8号线，连上了花生免费wifi，果然－－－广告都不见了贴一些代码。这边一定要注意，拦截的话一定不能返回null，返回null的话，webview回去正常加载 5-拓展中国的网络大环境，http劫持广告很难从源头杜绝。随着越来越多的app嵌入h5,会有越来越多的人在手机端遇到这种劫持广告，作为开发者，一定不要觉得说，这是用户使用免费wifi的原因或者这是运营商的植入广告。我们有的时候改变不了大环境，那么我们做出更多的努力，在app端让劫持广告更难成功。 码农的路上，纵情向前！]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>烦人的广告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iphone时间格式的支持]]></title>
    <url>%2F2018%2F12%2F14%2Fiphone%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[今天带给大家的是 html中 safari的 new Date的时间格式支持问题 当前苹果的手机端对 时间格式支持不包括 “yyyy-mm-dd” , 他所支持的是“yyyy/mm/dd”。 当然小伙伴可以用 repalce（）方法进行 “-” “/“的替换处理。然后在这里还有一个坑等着你，那就是repalce（）的方法只会替换第一个“-”。针对这一类问题，处理方法是正则表达式，因为repalce支持正则表达式。 /g的意思就是匹配全部，这样就可以完成了。具体代码如下。 123456var newDate1 = "2017-04-20";var newDate2 = newDate1.repalcereplace(/-/g,"/"); ---------(注意引号)。重点一 ： 时间格式支持问题。重点二 : repalce()方法的灵活运用。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6块级作用域的优点]]></title>
    <url>%2F2018%2F12%2F14%2FES6%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E4%BC%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[我们都知道在ES6中新增加了一个块级作用域，块级作用域相对于ES5的全局与局部作用局的优势在哪？———————–先看es5的全局 和 局部 作用域的弊端。 一、内层变量可能会覆盖外层变量。 代码验证一下：12345678var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'helloworld'; &#125;&#125;f(); // undefined 二 、循环变量泄露为全局变量。 代码验证：12345ar s = 'bingo';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 ——————ES6块级作用域的优势。1 外层代码块不受内层代码块的影响.1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 2 外层作用域无法读取内层作用域的变量。1234&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错 原因外层没有声明 且不能读取内层作用域的赋值。&#125;; 3 内层作用域可以定义外层作用域的同名变量，而不受影响。1234&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;; 4 函数自执行 精简代码12① (function()&#123; &#125;)();② &#123; &#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularJs--02]]></title>
    <url>%2F2018%2F12%2F14%2FangularJs-02%2F</url>
    <content type="text"><![CDATA[快速的angular的项目。今天分享的是angular路由的二级嵌套，可以理解为深层嵌套，我用到了ui-route，顺便在这发一下cdn，方便使用。 https://cdnjs.cloudflare.com/ajax/libs/angular-ui-router/1.0.3/angular-ui-router.min.js 1、设置angualr的启动config：//注意config的注入 贴一下代码123456789101112131415161718192021222324252627282930313233343536app.config(function($stateProvider, $urlRouterProvider)&#123;$urlRouterProvider.otherwise('list2'); //可以在路径没有匹配的路由的时候，跳转到一个默认的路径$stateProvider.state('list2',&#123;url: '/list2',templateUrl: './htmls/list2.html',&#125;).state('list3',&#123;url: '/list3',templateUrl: './htmls/list3.html',&#125;).state('list1',&#123;url: '/list1',templateUrl: './htmls/list1.html',controller: function($state)&#123; $state.go('list1.main1'); //默认显示第一个tab &#125;&#125;).state('list1.main1',&#123;url: '/main',templateUrl: './htmls/listmain1.html',&#125;).state('list1.main2',&#123;url: '/main',templateUrl: './htmls/listmain2.html',&#125;).state('list1.main3',&#123;url: '/main',templateUrl: './htmls/listmain3.html',&#125;)&#125;)//再看一下html结构page1page2page3 //ui-route 中 路由跳转用的是 ui-serf， 视图为 ui-view。我在这儿设置了三个分别为 list 1 2 3 的 一级路由。 由index。html页面的导航进行跳转。当然这个是最基本的。我还设置了 list1 视图中 三个二级路由名字分别为 listmain 1 2 3 。这时候路由跳转需要写在 list1视图的木模板中，因为二级路由是从list1的视图模板中切换的。 需要注意的是： 我们浏览网页 页面内容需要填充的 ，需要给用户展示的。如何你只设置了二级路由，那么功能可以实现 ，如果不点击切换 ，网页是空的。 我们需要设置默认显示的view。 在这可以用到go()的方法。123controller: function($state)&#123; $state.go('list1.main1'); //默认显示第一个视图 参数为路由名称。&#125; 这样点击list1的时候 呈现给用户的就是 list1视图 和 list1视图中liatmain子视图。这就是二级路由的嵌套。**控制器绑定最好是写在html模块中。 tanks。*]]></content>
      <categories>
        <category>angularJs</category>
      </categories>
      <tags>
        <tag>angularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularJs--01]]></title>
    <url>%2F2018%2F12%2F14%2FangularJs--01%2F</url>
    <content type="text"><![CDATA[今天看到有人在论坛里问有没有Angular的实战项目，接触实战项目成长快，积累经验没什么错，我特别想说一句Angualr的官方tutorial看过吗？这里面就介绍的很详细从配置到服务到解答。我在这儿发一下网址： https://www.tutorialspoint.com/angularjs/angularjs_overview.htm 今天与大家分享一下 ng-bind与ng-model区别 , 这也是最基本的，也是能体现angular的机制的一个。数据的单项 m -v 与 数据的双向 m- v v-m 的精髓。首先要知道 ng-bind 是数据的单项绑定， ng-model是数据的双向绑定。这个一定要理解。 ng-bind是从$scope -&gt; view的单向绑定，也就是说ng-bind是相当于，是用于展示数据的。 ng-modle是$scope view的双向绑定 也就是说 modle 可双向修改数据的 可以实现与用户的交互。 用户可以修改视图数据来达到不同展示效果。 然后 bind 是我们开发人员 ， 来修改数据达到展示给用户的一个过程。 这也就是Angular的精髓 MVVM modle - view view - modle]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>angularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp自动化构建工具]]></title>
    <url>%2F2018%2F12%2F14%2Fgulp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[首先，肯定是需要下载安装node.js的。安装完成之后我们可以在操作命令行来查看版本号。12node -vnmp -v 然后我们可以创建项目 ， 在这儿要提到一点 gulp安装 一个是全局的一个是依赖项目的。 对应的命令行是1npm gulp -g 依赖项目的需要先进入到项目路径 然后1npm gulp --save-dev 1npm init //我们对项目信息进行填充 包括项目名称 版本号 描述等等。 123456var gulp = require('gulp'), minifycss =require('gulp-minify-css'), //CSS压缩 concat =require('gulp-concat'), // 文件合并 uglify =require('gulp-uglify'), //js压缩插件 rename =require('gulp-rename'), // 重命名 order = require('gulp-order'); //顺序 这是经常用到的几个插件。 作用都在后面注释里。 他们可以执行代码的合并压缩重命名。提高项目运行效率。这是基本的，当然需要我们创建一个gulpfile.js的文件 来执行。 下面我贴上里面的代码 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp'), minifycss =require('gulp-minify-css'), //CSS压缩 concat =require('gulp-concat'), // 文件合并 uglify =require('gulp-uglify'), //js压缩插件 rename =require('gulp-rename'), // 重命名 order = require('gulp-order');//1.压缩cssgulp.task('minifycss', function() &#123; returngulp.src('css*.js')// .pipe(order(// ['js/ui-route.js','js/config/config.js','js/colltor/list1.js']// ))// .pipe(concat('all.js')) //合并所有js到all.js// .pipe(gulp.dest('dist/js')) //输出all.js到文件夹// .pipe(rename(&#123;suffix: '.min'&#125;)) //rename压缩后的文件名// .pipe(uglify()) //压缩// .pipe(gulp.dest('dist/js')); //输出//&#125;);//3.将以上两个任务合并为一个任务gulp.task('build', ['minifycss', 'minifyjs']);//4.监视文件的变化，自动执行任务// 监视文件的变化，当文件有更新时执行build任务gulp.task('watch', function () &#123; gulp.watch(['src/js/*.js', 'src/css/*.css'], ['build']);&#125;);//5.定义默认任务gulp.task('default', ['build', 'watch']);代码后面都有注释 。 这就是从 代码的合并 =》 压缩 =》重命名 =》输出的过程。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsDoc文档自动化生成]]></title>
    <url>%2F2018%2F12%2F14%2FjsDoc%E6%96%87%E6%A1%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[​​十分推荐，编辑代码的时候有写注释的习惯，后期直接自动生成文档，不用劳神费力的一点找一点写。 前期工作还是配置环境， 下载JDK 配置变量等等就不提了， 我是用的grunt软件来配合项目使用的 ， 压缩 编译 格式化 文档自动化 ， 很方便。 想要在项目里面支持grunt-jsdoc其实很简单。因为本身grunt就是一个基于Node.js的软件，其插件也是通过npm进行维护的，那么我们安装jsdoc其实很方便，就一行代码。 1npm install grunt-jsdoc --save-dev 下载完成之后就是配置 grunt-jsdoc的问题，其实很简单，配置如下： 1grunt.initConfig（&#123;jsdoc ：&#123; dist : &#123; src: [ 详细用法看官方中文文档]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jsDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mailto的用法及attach附件测试结果。]]></title>
    <url>%2F2018%2F12%2F14%2Fmailto%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8Aattach%E9%99%84%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E3%80%82%2F</url>
    <content type="text"><![CDATA[mailto是一个发送电子邮件非常方便的方法，功能上面也是能满足正常的使用。 格式一、 Mailto后为收件人地址二、cc后为抄送地址三、bcc后为密件抄送地址四、subject后为邮件的主题五、body后为邮件的内容如果Mailto后面同时有多个参数的话，第一个参数必须以“?”开头，后面的每一个都以“&amp;”开头。使用1）基本的 mailto单击这里给我发电子邮件 当浏览者点击这个链接时，浏览器会自动调用默认的客户端电子邮件程序，并在收件人框中自动填上收件人的地址下面。 2）包含抄送地址在收件人地址后用?cc=开头，你可以填写抄送地址，示例代码如下：1&lt;"mailto:abc@sina.com.cn?cc=abc@sina.com.cn"&gt;发送 3）包含密件抄送地址紧跟着抄送地址之后，写上&amp;bcc=，就可以填上密件抄送地址了。1"mailto:abc@sina.com.cn?cc=aaa@sina.com.cn&amp;bcc=bbb@sina.com.cn"&gt;发送 4）包含多个收件人、抄送、密件抄送人用分号隔开多个收件人的地址即可实现： 5）包含主题用?subject=可以填上主题1a href="mailto:abc@sina.com.cn?cc=abc@sina.com.cn?subject=发送电子邮件" 完整实例1Mailto:xxx@xxx.com?cc=xxx@xxx.com&amp;bcc=mmm@mm.com&amp;subject=主题&amp;body=邮件内容 在这里要提及一下 附件 ， 网上好多网友提到了前端的mailto调用 attach可以发送附件，我自己测试了好多种方法，发现并不能发送附件，我觉得这个前端调用attach发附件的可行性不高，需要借助第三方客户端工具进行辅助]]></content>
      <categories>
        <category>mailto疑点</category>
      </categories>
      <tags>
        <tag>mailto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在关于mailto的使用中，关于url长度出现超长的问题]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%9C%A8%E5%85%B3%E4%BA%8Emailto%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%AD%EF%BC%8C%E5%85%B3%E4%BA%8Eurl%E9%95%BF%E5%BA%A6%E5%87%BA%E7%8E%B0%E8%B6%85%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[#搜索过程中发现，各浏览器与各Web Server对URL均有长度的限制如下： 一、IEIE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。 二、Firefox (Browser)Firefox浏览器URL的长度限制为65,536个字符，但当我测试时，最大只能处理8182个字符，这是因为url的长度除了浏览器限制外 三、Safari (Browser)URL最大长度限制为 80,000个字符。 四、Opera (Browser)URL最大长度限制为190,000个字符。 五、Google (chrome)url长度一旦超过8182个字符时，出现如下服务器错误： 如果你发的正文太长，也就是body后面的值太长，mailto 无法响应。 我暂时还没有找到好的解决办法，可以的话变通一下。​​​​]]></content>
      <categories>
        <category>mailto疑点</category>
      </categories>
      <tags>
        <tag>mailto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享两个地图框架]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E5%9C%B0%E5%9B%BE%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[leaflet1https://leafletjs.com/ truf1http://turfjs.org/]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leaflet.js</tag>
        <tag>turf.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ的插件编写以及个人经历过需要注意的地方]]></title>
    <url>%2F2018%2F12%2F14%2FJQ%E7%9A%84%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E4%BB%A5%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86%E8%BF%87%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%2F</url>
    <content type="text"><![CDATA[啰嗦一下，很希望各位‘攻城狮’们能和大家一起分享，一起成长。当然，也可以一起吹。哈，不废话，进入正题。JQ是一个非常好用的库，但是在解决自己项目的实际问题中，难免会遇到需要去拓展的方法，需要我们用插件去实现。当然JQ的也制定了官方的拓展规范，小伙伴可以去看一下。 编写原则1、避免破坏第三方2、避免产生全局依赖，规范作用域，避免产生代码污染。3、兼容jQuery操作符’$’和’jQuery’代码格式1(function ($) &#123;//插件内部代码 &#125;)(jQuery); 扩展插件1jQuery.fn.extend(object) 扩展jquery 方法，制作插件闭包限定命名空间 1(function ($) &#123; $.fn.extend(&#123; "highLight":function(options)&#123; //do something &#125; &#125;); &#125;)(window.jQuery); 在这里 window.jQuery 与 jQuery 与 $ 三者是一样的 ~！！！~ 给插件默认参数，实现 插件的功能闭包限定命名空间1(function ($) &#123; $.fn.extend(&#123; "highLight": function (options) &#123; var opts = $.extend(&#123;&#125;, defaluts, options); 使用jQuery.extend 覆盖插件默认参数 this.each(function () { //这里的this 就是 jQuery对象//遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。//var $this = $(this);获取当前dom 的 jQuery对象，这里的this是当前循环的dom//根据参数来设置 dom的样式1$this.css(&#123; backgroundColor: opts.background, color: opts.foreground &#125;); &#125;); &#125; &#125;); //默认参数1var defaluts = &#123; foreground: 'red', background: 'yellow' &#125;; &#125;)(window.jQuery); 在这儿要说一下 $.extend () 而且是将该option 合并到调用 extend方法 的对象中去.]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IsValid函数基本用法]]></title>
    <url>%2F2018%2F12%2F14%2FIsValid%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[功能检查对象变量是否已经实例化，即实例变量的值是否是个有效的对象。 语法1IsValid(objectname) 参数objectname:要检查的对象名。 返回值Boolean。如果指定对象已经创建了对此案实例，那么IsValid()函数返回True,否则返回FALSE。如果参数obejctname的值为NULL，IsValid()函数返回NULL。 示例1if (!isValid(options)) return this;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端input获取焦点弹出输入板从而影响position定位的问题]]></title>
    <url>%2F2018%2F12%2F14%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFinput%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E5%BC%B9%E5%87%BA%E8%BE%93%E5%85%A5%E6%9D%BF%E4%BB%8E%E8%80%8C%E5%BD%B1%E5%93%8Dposition%E5%AE%9A%E4%BD%8D%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[移动端里面常常会遇到 需要填值得输入框 这个输入框获取焦点之后，从而弹出输入板打字输入。 这时候弹出的输入板会影响到页面的底部布局 （底部用position定位）。我亲测了一个小简便方法来消除这种影响。12345678910111213$('.login-cont-ipt').bind('focus',function()&#123; $('.login-footer').css('position','static'); //或者$('#viewport').height($(window).height()+'px');&#125;).bind('blur',function()&#123; $('.login-footer').css(&#123;'position':'fixed','bottom':'0'&#125;); //或者$('#viewport').height('auto');&#125;); 原理就是 position的static static是默认值，让元素处于正常的流中 且 忽略 top…..left…等。这就很容易理解了 输入框获取焦点时 让底部的定位元素处于正常的流 就不会出现反常的遮挡。​​​​]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序页面之间跳转的方式]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[先导 我们Activity和Fragment都有栈的概念在里面，微信小程序页面也有栈的概念在里面。微信小程序页面跳转有四种方式： 1wx.navigateTo(OBJECT) 1wx.redirectTo(OBJECT) 1wx.switchTab(OBJECT) 1wx.navigateBack(OBJECT) 分析1.其中navigateTo是将原来的页面保存在页面栈中，在跳入到下一个页面的时候目标页面也进栈，只有在这个情况下点击手机的返回按钮才可以跳转到上一个页面;2.redirectTo和switchTab都是先清除栈中原来的页面，然后目标页面进栈，使用这两种跳转方式，都不能通过系统的返回键回到上一个页面，而是直接退出小程序；3.redirectTo使用的时候一定要配合tabBar或是页面里面可以再次跳转按钮，否则无法回到上一个页面；4.switchTab跳转的页面必须是tabBar中声明的页面；5.tabBar中定义的字段不能超过5个页面，小程序的页面栈层次也不能超过5层。6.navigateBack只能返回到页面栈中的指定页面，一般和navigateTo配合使用。7.wx.navigateTo 和 wx.redirectTo 不允许跳转到 tabbar 页面，只能用 wx.switchTab 跳转到 tabbar 页面 页面跳转的具体操作(1) wx.navigateTo(OBJECT)保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。示例代码:1wx.navigateTo(&#123; url: 'test?id=1'//实际路径要写全 &#125;) (2) wx.redirectTo(OBJECT)关闭当前页面，跳转到应用内的某个页面。示例代码:1wx.redirectTo(&#123; url: 'test?id=1' &#125;) (3) wx.switchTab(OBJECT)跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面示例代码:123&#123; "tabBar": &#123; "list": [&#123; "pagePath": "index", "text": "首页" &#125;,&#123; "pagePath": "other", "text": "其他" &#125;] &#125; &#125;wx.switchTab(&#123; url: '/index' &#125;) (4) wx.navigateBack(OBJECT)关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages()) 获取当前的页面栈，决定需要返回几层。注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。示例代码:1wx.navigateTo(&#123; url: 'B?id=1' &#125;) (5) 使用标签实现页面跳转页面链接 示例代码:1"navigate?title=navigate" hover-class="navigator-hover"&gt;跳转到新页面 "redirect?title=redirect" open-type="redirect" hover-class="other-navigator-hover"&gt;在当前页打开 "index" open-type="switchTab" hover-class="other-navigator-hover"&gt;切换 Tab 参数传递通过路径传递参数通过路径传递参数在wx.navigateTo(OBJECT)、wx.redirectTo(OBJECT)和中使用方法相同 示例代码：以wx.navigateTo为代表 123wx.navigateTo(&#123; url: 'test?id=1'//实际路径要写全 &#125;)test.js Page(&#123; onLoad: function(option)&#123; console.log(option.id) &#125; &#125;) 参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；test?id=1 中id为参数键，1 为参数值在目的页面中onLoad（）方法中option对象即为参数对象，可以通过参数键来取出参数值​​​​]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newBolg]]></title>
    <url>%2F2018%2F12%2F14%2FnewBolg%2F</url>
    <content type="text"><![CDATA[我的个人博客：https://okven.github.io/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[filename]]></title>
    <url>%2F2018%2F12%2F13%2Ffilename%2F</url>
    <content type="text"><![CDATA[2.直线段的裁剪2.1 中线分割法2.2 Liang2.2.1 其他的]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
