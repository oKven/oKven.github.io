<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[烦人的广告]]></title>
    <url>%2F2018%2F12%2F14%2F%E7%83%A6%E4%BA%BA%E7%9A%84%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[让烦人的广告滚出我们的界面-码农的路上，纵情向前！ 1-现像最近越来越多的用户向客服反映，在使用我们的App过程中，会莫名其妙的在底部出现广告，甚至黄色信息。这些信息不但困扰了用户，影响用户的使用,最关键是使得用户散失对我们公司的信任,觉得我们公司的开发技术不行（什么？？？什么？技术不行？？出来，出来，我要和你大战三百回合、）。那么这个时候不仅仅是要给用户一个合理的解释，查出现象的原因，杜绝现象的再发生就显得迫不及待了。 2-原因当时接到用户反馈，我们第一时间对现象发生的原因进行了一系列猜想： 1.是不是我们项目中的第三方jar非官方版本，被植入了一些广告代码2.dns劫持3.http劫持做技术的都明白，那就是经验有的时候是助力，也是阻力。很多时候我们会被我们的经验所羁绊。很多资深技术，看到第一条的现象很容易冒出脑海的肯定是：劫持。那么第一条的理由是不是可能导致这种现象，从实现来说，完全可以做到的。现在很多开发人员平常开发过程随意之极，频繁的在项目使用一些小众且不规范的第三方jar包。而这些第三方jar也会是一些广告的来源。甚至是安全隐患的来源。 1.用的是4g还是wifi？2.如果是wifi，是不是路边免费的wifi？3.在什么页面出现？方便定位是h5页面还是原生界面，对大部分用户，千万不要问他是h5还是原生，只能自己分析，如果原生界面也出现那么第三方jar出现问题的概率很大，如果只是h5界面，那么劫持的可能性很大 4.使用的是Android 还是iOS客户端 综合用户的答案，我们总结如下：1.4g，wifi都出现了。2.出现的位置都是h5页面。3.android ios都出现了 3-排查那基本可以定位是网络劫持原因。那么网络劫持有2种 1.dns劫持2.http劫持什么是DNS劫持: 首先DNS是什么。在因特网中，机器相互识别靠的是ip，而ip单纯的无意义数字的结合，很难被人类熟记，所以产生了域名，例如www.baidu.com就是域名。那么问题来了，我们输入域名，机器又不认识，那么机器怎么去访问？那么就轮到DNS出场了，DNS在作为域名和IP地址相互映射的一个分布式数据库，就是我们的浏览器，会将域名拿到DNS去解析出ip地址来访问，DNS劫持是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。 通俗来说，就是他给我们指向了另一个地址，或者让我们无法访问。电信以前的互联星空的，每次联网打开的第一个网页永远是互联星空。就是典型的DNS劫持。 什么是http劫持: 百度百科的说法：HTTP劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的网络数据报文，目的是让用户端程序解释“错误”的数据，并以弹出新窗口的形式在使用者界面展示宣传性广告或者直接显示某网站的内容。 通俗来说，你要去百度的首页，他会给你百度首页，然后再百度首页的某个部位＋个广告。更具欺骗性，危害更大。（毕竟直接给你导向另外一个网址，用户也不是傻逼，上当的可能性很小。）而这也是现在很多免费wifi植入广告的手段，因为这样能更多的点击。 而很明显，我们遇到的是第二种 4-解决方案原因定位之后，就是制定解决方案了。根据这个http劫持的特性，我们可以很简单的给出解决方案: https。https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。就是说数据交流是加密的那么所谓的在返回数据里面加点广告就无从谈起了。而且https也能解决dns劫持（基本杜绝）。 那么我们需要一个临时解决方案。那么怎么解决呢。既然这些猥琐的劫持者通过插入一段js，那么不让他执行这段js就好了。因为android3.0以后webview提供了方法可以方便的拦截到所有的ajax请求，那么所有的js，图片下载都可以拦截到。我们可以做个区分，对要执行的js做一个筛选。 从API 11开始引入，API 21弃用@Override 1public WebResourceResponse shouldInterceptRequest(WebView view, String url) &#123; return Tool.getResponse(WebViewActivity.this,url,control); &#125; 从API 21开始引入 @Override 1public WebResourceResponse shouldInterceptRequest(WebView view, final WebResourceRequest request) &#123; return Tool.getResponse(WebViewActivity.this,request.getUrl().toString(),control); &#125; webview在WebViewClient里提供的2种拦截ajax请求的方法所有我们做了白名单和黑名单的机制，因为现在hybird的开发流行，app嵌入了很多h5，而h5页面的制作也参杂了很多第三方的jar，如果只是单纯的把公司域名下的请求之外的请求拦截，很容易导致h5的某些功能无法使用，所有我们采用了拦截开关的机制。在前2天上报非白名单的url，方便我们派出一些误伤的url，这样加入到白名单，以后开启拦截的开关，就能做到无误伤。（https才是正统的解决方案，拦截请求的局限性太大，而且很容易导致功能误伤）。 然后我拿着我开启了拦截开关的app，上了上海的8号线，连上了花生免费wifi，果然－－－广告都不见了贴一些代码。这边一定要注意，拦截的话一定不能返回null，返回null的话，webview回去正常加载 5-拓展中国的网络大环境，http劫持广告很难从源头杜绝。随着越来越多的app嵌入h5,会有越来越多的人在手机端遇到这种劫持广告，作为开发者，一定不要觉得说，这是用户使用免费wifi的原因或者这是运营商的植入广告。我们有的时候改变不了大环境，那么我们做出更多的努力，在app端让劫持广告更难成功。 码农的路上，纵情向前！]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>烦人的广告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iphone时间格式的支持]]></title>
    <url>%2F2018%2F12%2F14%2Fiphone%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[今天带给大家的是 html中 safari的 new Date的时间格式支持问题 当前苹果的手机端对 时间格式支持不包括 “yyyy-mm-dd” , 他所支持的是“yyyy/mm/dd”。 当然小伙伴可以用 repalce（）方法进行 “-” “/“的替换处理。然后在这里还有一个坑等着你，那就是repalce（）的方法只会替换第一个“-”。针对这一类问题，处理方法是正则表达式，因为repalce支持正则表达式。 /g的意思就是匹配全部，这样就可以完成了。具体代码如下。 123456var newDate1 = "2017-04-20";var newDate2 = newDate1.repalcereplace(/-/g,"/"); ---------(注意引号)。重点一 ： 时间格式支持问题。重点二 : repalce()方法的灵活运用。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6块级作用域的优点]]></title>
    <url>%2F2018%2F12%2F14%2FES6%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E4%BC%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[我们都知道在ES6中新增加了一个块级作用域，块级作用域相对于ES5的全局与局部作用局的优势在哪？———————–先看es5的全局 和 局部 作用域的弊端。 一、内层变量可能会覆盖外层变量。 代码验证一下：12345678var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'helloworld'; &#125;&#125;f(); // undefined 二 、循环变量泄露为全局变量。 代码验证：12345ar s = 'bingo';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 ——————ES6块级作用域的优势。1 外层代码块不受内层代码块的影响.1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 2 外层作用域无法读取内层作用域的变量。1234&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错 原因外层没有声明 且不能读取内层作用域的赋值。&#125;; 3 内层作用域可以定义外层作用域的同名变量，而不受影响。1234&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;; 4 函数自执行 精简代码12① (function()&#123; &#125;)();② &#123; &#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularJs--02]]></title>
    <url>%2F2018%2F12%2F14%2FangularJs-02%2F</url>
    <content type="text"><![CDATA[快速的angular的项目。今天分享的是angular路由的二级嵌套，可以理解为深层嵌套，我用到了ui-route，顺便在这发一下cdn，方便使用。 https://cdnjs.cloudflare.com/ajax/libs/angular-ui-router/1.0.3/angular-ui-router.min.js 1、设置angualr的启动config：//注意config的注入 贴一下代码123456789101112131415161718192021222324252627282930313233343536app.config(function($stateProvider, $urlRouterProvider)&#123;$urlRouterProvider.otherwise('list2'); //可以在路径没有匹配的路由的时候，跳转到一个默认的路径$stateProvider.state('list2',&#123;url: '/list2',templateUrl: './htmls/list2.html',&#125;).state('list3',&#123;url: '/list3',templateUrl: './htmls/list3.html',&#125;).state('list1',&#123;url: '/list1',templateUrl: './htmls/list1.html',controller: function($state)&#123; $state.go('list1.main1'); //默认显示第一个tab &#125;&#125;).state('list1.main1',&#123;url: '/main',templateUrl: './htmls/listmain1.html',&#125;).state('list1.main2',&#123;url: '/main',templateUrl: './htmls/listmain2.html',&#125;).state('list1.main3',&#123;url: '/main',templateUrl: './htmls/listmain3.html',&#125;)&#125;)//再看一下html结构page1page2page3 //ui-route 中 路由跳转用的是 ui-serf， 视图为 ui-view。我在这儿设置了三个分别为 list 1 2 3 的 一级路由。 由index。html页面的导航进行跳转。当然这个是最基本的。我还设置了 list1 视图中 三个二级路由名字分别为 listmain 1 2 3 。这时候路由跳转需要写在 list1视图的木模板中，因为二级路由是从list1的视图模板中切换的。 需要注意的是： 我们浏览网页 页面内容需要填充的 ，需要给用户展示的。如何你只设置了二级路由，那么功能可以实现 ，如果不点击切换 ，网页是空的。 我们需要设置默认显示的view。 在这可以用到go()的方法。123controller: function($state)&#123; $state.go('list1.main1'); //默认显示第一个视图 参数为路由名称。&#125; 这样点击list1的时候 呈现给用户的就是 list1视图 和 list1视图中liatmain子视图。这就是二级路由的嵌套。**控制器绑定最好是写在html模块中。 tanks。*]]></content>
      <categories>
        <category>angularJs</category>
      </categories>
      <tags>
        <tag>angularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularJs--01]]></title>
    <url>%2F2018%2F12%2F14%2FangularJs--01%2F</url>
    <content type="text"><![CDATA[今天看到有人在论坛里问有没有Angular的实战项目，接触实战项目成长快，积累经验没什么错，我特别想说一句Angualr的官方tutorial看过吗？这里面就介绍的很详细从配置到服务到解答。我在这儿发一下网址： https://www.tutorialspoint.com/angularjs/angularjs_overview.htm 今天与大家分享一下 ng-bind与ng-model区别 , 这也是最基本的，也是能体现angular的机制的一个。数据的单项 m -v 与 数据的双向 m- v v-m 的精髓。首先要知道 ng-bind 是数据的单项绑定， ng-model是数据的双向绑定。这个一定要理解。 ng-bind是从$scope -&gt; view的单向绑定，也就是说ng-bind是相当于，是用于展示数据的。 ng-modle是$scope view的双向绑定 也就是说 modle 可双向修改数据的 可以实现与用户的交互。 用户可以修改视图数据来达到不同展示效果。 然后 bind 是我们开发人员 ， 来修改数据达到展示给用户的一个过程。 这也就是Angular的精髓 MVVM modle - view view - modle]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>angularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp自动化构建工具]]></title>
    <url>%2F2018%2F12%2F14%2Fgulp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[首先，肯定是需要下载安装node.js的。安装完成之后我们可以在操作命令行来查看版本号。12node -vnmp -v 然后我们可以创建项目 ， 在这儿要提到一点 gulp安装 一个是全局的一个是依赖项目的。 对应的命令行是1npm gulp -g 依赖项目的需要先进入到项目路径 然后1npm gulp --save-dev 1npm init //我们对项目信息进行填充 包括项目名称 版本号 描述等等。 123456var gulp = require('gulp'), minifycss =require('gulp-minify-css'), //CSS压缩 concat =require('gulp-concat'), // 文件合并 uglify =require('gulp-uglify'), //js压缩插件 rename =require('gulp-rename'), // 重命名 order = require('gulp-order'); //顺序 这是经常用到的几个插件。 作用都在后面注释里。 他们可以执行代码的合并压缩重命名。提高项目运行效率。这是基本的，当然需要我们创建一个gulpfile.js的文件 来执行。 下面我贴上里面的代码 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp'), minifycss =require('gulp-minify-css'), //CSS压缩 concat =require('gulp-concat'), // 文件合并 uglify =require('gulp-uglify'), //js压缩插件 rename =require('gulp-rename'), // 重命名 order = require('gulp-order');//1.压缩cssgulp.task('minifycss', function() &#123; returngulp.src('css*.js')// .pipe(order(// ['js/ui-route.js','js/config/config.js','js/colltor/list1.js']// ))// .pipe(concat('all.js')) //合并所有js到all.js// .pipe(gulp.dest('dist/js')) //输出all.js到文件夹// .pipe(rename(&#123;suffix: '.min'&#125;)) //rename压缩后的文件名// .pipe(uglify()) //压缩// .pipe(gulp.dest('dist/js')); //输出//&#125;);//3.将以上两个任务合并为一个任务gulp.task('build', ['minifycss', 'minifyjs']);//4.监视文件的变化，自动执行任务// 监视文件的变化，当文件有更新时执行build任务gulp.task('watch', function () &#123; gulp.watch(['src/js/*.js', 'src/css/*.css'], ['build']);&#125;);//5.定义默认任务gulp.task('default', ['build', 'watch']);代码后面都有注释 。 这就是从 代码的合并 =》 压缩 =》重命名 =》输出的过程。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsDoc文档自动化生成]]></title>
    <url>%2F2018%2F12%2F14%2FjsDoc%E6%96%87%E6%A1%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[​​十分推荐，编辑代码的时候有写注释的习惯，后期直接自动生成文档，不用劳神费力的一点找一点写。 前期工作还是配置环境， 下载JDK 配置变量等等就不提了， 我是用的grunt软件来配合项目使用的 ， 压缩 编译 格式化 文档自动化 ， 很方便。 想要在项目里面支持grunt-jsdoc其实很简单。因为本身grunt就是一个基于Node.js的软件，其插件也是通过npm进行维护的，那么我们安装jsdoc其实很方便，就一行代码。 1npm install grunt-jsdoc --save-dev 下载完成之后就是配置 grunt-jsdoc的问题，其实很简单，配置如下： 1grunt.initConfig（&#123;jsdoc ：&#123; dist : &#123; src: [ 详细用法看官方中文文档]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jsDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mailto的用法及attach附件测试结果。]]></title>
    <url>%2F2018%2F12%2F14%2Fmailto%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8Aattach%E9%99%84%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E3%80%82%2F</url>
    <content type="text"><![CDATA[mailto是一个发送电子邮件非常方便的方法，功能上面也是能满足正常的使用。 格式一、 Mailto后为收件人地址二、cc后为抄送地址三、bcc后为密件抄送地址四、subject后为邮件的主题五、body后为邮件的内容如果Mailto后面同时有多个参数的话，第一个参数必须以“?”开头，后面的每一个都以“&amp;”开头。使用1）基本的 mailto单击这里给我发电子邮件 当浏览者点击这个链接时，浏览器会自动调用默认的客户端电子邮件程序，并在收件人框中自动填上收件人的地址下面。 2）包含抄送地址在收件人地址后用?cc=开头，你可以填写抄送地址，示例代码如下：1&lt;"mailto:abc@sina.com.cn?cc=abc@sina.com.cn"&gt;发送 3）包含密件抄送地址紧跟着抄送地址之后，写上&amp;bcc=，就可以填上密件抄送地址了。1"mailto:abc@sina.com.cn?cc=aaa@sina.com.cn&amp;bcc=bbb@sina.com.cn"&gt;发送 4）包含多个收件人、抄送、密件抄送人用分号隔开多个收件人的地址即可实现： 5）包含主题用?subject=可以填上主题1a href="mailto:abc@sina.com.cn?cc=abc@sina.com.cn?subject=发送电子邮件" 完整实例1Mailto:xxx@xxx.com?cc=xxx@xxx.com&amp;bcc=mmm@mm.com&amp;subject=主题&amp;body=邮件内容 在这里要提及一下 附件 ， 网上好多网友提到了前端的mailto调用 attach可以发送附件，我自己测试了好多种方法，发现并不能发送附件，我觉得这个前端调用attach发附件的可行性不高，需要借助第三方客户端工具进行辅助]]></content>
      <categories>
        <category>mailto疑点</category>
      </categories>
      <tags>
        <tag>mailto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在关于mailto的使用中，关于url长度出现超长的问题]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%9C%A8%E5%85%B3%E4%BA%8Emailto%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%AD%EF%BC%8C%E5%85%B3%E4%BA%8Eurl%E9%95%BF%E5%BA%A6%E5%87%BA%E7%8E%B0%E8%B6%85%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[#搜索过程中发现，各浏览器与各Web Server对URL均有长度的限制如下： 一、IEIE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。 二、Firefox (Browser)Firefox浏览器URL的长度限制为65,536个字符，但当我测试时，最大只能处理8182个字符，这是因为url的长度除了浏览器限制外 三、Safari (Browser)URL最大长度限制为 80,000个字符。 四、Opera (Browser)URL最大长度限制为190,000个字符。 五、Google (chrome)url长度一旦超过8182个字符时，出现如下服务器错误： 如果你发的正文太长，也就是body后面的值太长，mailto 无法响应。 我暂时还没有找到好的解决办法，可以的话变通一下。​​​​]]></content>
      <categories>
        <category>mailto疑点</category>
      </categories>
      <tags>
        <tag>mailto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享两个地图框架]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E5%9C%B0%E5%9B%BE%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[leaflet1https://leafletjs.com/ truf1http://turfjs.org/]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leaflet.js</tag>
        <tag>turf.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ的插件编写以及个人经历过需要注意的地方]]></title>
    <url>%2F2018%2F12%2F14%2FJQ%E7%9A%84%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E4%BB%A5%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86%E8%BF%87%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%2F</url>
    <content type="text"><![CDATA[啰嗦一下，很希望各位‘攻城狮’们能和大家一起分享，一起成长。当然，也可以一起吹。哈，不废话，进入正题。JQ是一个非常好用的库，但是在解决自己项目的实际问题中，难免会遇到需要去拓展的方法，需要我们用插件去实现。当然JQ的也制定了官方的拓展规范，小伙伴可以去看一下。 编写原则1、避免破坏第三方2、避免产生全局依赖，规范作用域，避免产生代码污染。3、兼容jQuery操作符’$’和’jQuery’代码格式1(function ($) &#123;//插件内部代码 &#125;)(jQuery); 扩展插件1jQuery.fn.extend(object) 扩展jquery 方法，制作插件闭包限定命名空间 1(function ($) &#123; $.fn.extend(&#123; "highLight":function(options)&#123; //do something &#125; &#125;); &#125;)(window.jQuery); 在这里 window.jQuery 与 jQuery 与 $ 三者是一样的 ~！！！~ 给插件默认参数，实现 插件的功能闭包限定命名空间1(function ($) &#123; $.fn.extend(&#123; "highLight": function (options) &#123; var opts = $.extend(&#123;&#125;, defaluts, options); 使用jQuery.extend 覆盖插件默认参数 this.each(function () { //这里的this 就是 jQuery对象//遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。//var $this = $(this);获取当前dom 的 jQuery对象，这里的this是当前循环的dom//根据参数来设置 dom的样式1$this.css(&#123; backgroundColor: opts.background, color: opts.foreground &#125;); &#125;); &#125; &#125;); //默认参数1var defaluts = &#123; foreground: 'red', background: 'yellow' &#125;; &#125;)(window.jQuery); 在这儿要说一下 $.extend () 而且是将该option 合并到调用 extend方法 的对象中去.]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IsValid函数基本用法]]></title>
    <url>%2F2018%2F12%2F14%2FIsValid%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[功能检查对象变量是否已经实例化，即实例变量的值是否是个有效的对象。 语法1IsValid(objectname) 参数objectname:要检查的对象名。 返回值Boolean。如果指定对象已经创建了对此案实例，那么IsValid()函数返回True,否则返回FALSE。如果参数obejctname的值为NULL，IsValid()函数返回NULL。 示例1if (!isValid(options)) return this;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端input获取焦点弹出输入板从而影响position定位的问题]]></title>
    <url>%2F2018%2F12%2F14%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFinput%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E5%BC%B9%E5%87%BA%E8%BE%93%E5%85%A5%E6%9D%BF%E4%BB%8E%E8%80%8C%E5%BD%B1%E5%93%8Dposition%E5%AE%9A%E4%BD%8D%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[移动端里面常常会遇到 需要填值得输入框 这个输入框获取焦点之后，从而弹出输入板打字输入。 这时候弹出的输入板会影响到页面的底部布局 （底部用position定位）。我亲测了一个小简便方法来消除这种影响。12345678910111213$('.login-cont-ipt').bind('focus',function()&#123; $('.login-footer').css('position','static'); //或者$('#viewport').height($(window).height()+'px');&#125;).bind('blur',function()&#123; $('.login-footer').css(&#123;'position':'fixed','bottom':'0'&#125;); //或者$('#viewport').height('auto');&#125;); 原理就是 position的static static是默认值，让元素处于正常的流中 且 忽略 top…..left…等。这就很容易理解了 输入框获取焦点时 让底部的定位元素处于正常的流 就不会出现反常的遮挡。​​​​]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序页面之间跳转的方式]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[先导 我们Activity和Fragment都有栈的概念在里面，微信小程序页面也有栈的概念在里面。微信小程序页面跳转有四种方式： 1wx.navigateTo(OBJECT) 1wx.redirectTo(OBJECT) 1wx.switchTab(OBJECT) 1wx.navigateBack(OBJECT) 分析1.其中navigateTo是将原来的页面保存在页面栈中，在跳入到下一个页面的时候目标页面也进栈，只有在这个情况下点击手机的返回按钮才可以跳转到上一个页面;2.redirectTo和switchTab都是先清除栈中原来的页面，然后目标页面进栈，使用这两种跳转方式，都不能通过系统的返回键回到上一个页面，而是直接退出小程序；3.redirectTo使用的时候一定要配合tabBar或是页面里面可以再次跳转按钮，否则无法回到上一个页面；4.switchTab跳转的页面必须是tabBar中声明的页面；5.tabBar中定义的字段不能超过5个页面，小程序的页面栈层次也不能超过5层。6.navigateBack只能返回到页面栈中的指定页面，一般和navigateTo配合使用。7.wx.navigateTo 和 wx.redirectTo 不允许跳转到 tabbar 页面，只能用 wx.switchTab 跳转到 tabbar 页面 页面跳转的具体操作(1) wx.navigateTo(OBJECT)保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。示例代码:1wx.navigateTo(&#123; url: 'test?id=1'//实际路径要写全 &#125;) (2) wx.redirectTo(OBJECT)关闭当前页面，跳转到应用内的某个页面。示例代码:1wx.redirectTo(&#123; url: 'test?id=1' &#125;) (3) wx.switchTab(OBJECT)跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面示例代码:123&#123; "tabBar": &#123; "list": [&#123; "pagePath": "index", "text": "首页" &#125;,&#123; "pagePath": "other", "text": "其他" &#125;] &#125; &#125;wx.switchTab(&#123; url: '/index' &#125;) (4) wx.navigateBack(OBJECT)关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages()) 获取当前的页面栈，决定需要返回几层。注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。示例代码:1wx.navigateTo(&#123; url: 'B?id=1' &#125;) (5) 使用标签实现页面跳转页面链接 示例代码:1"navigate?title=navigate" hover-class="navigator-hover"&gt;跳转到新页面 "redirect?title=redirect" open-type="redirect" hover-class="other-navigator-hover"&gt;在当前页打开 "index" open-type="switchTab" hover-class="other-navigator-hover"&gt;切换 Tab 参数传递通过路径传递参数通过路径传递参数在wx.navigateTo(OBJECT)、wx.redirectTo(OBJECT)和中使用方法相同 示例代码：以wx.navigateTo为代表 123wx.navigateTo(&#123; url: 'test?id=1'//实际路径要写全 &#125;)test.js Page(&#123; onLoad: function(option)&#123; console.log(option.id) &#125; &#125;) 参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；test?id=1 中id为参数键，1 为参数值在目的页面中onLoad（）方法中option对象即为参数对象，可以通过参数键来取出参数值​​​​]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newBolg]]></title>
    <url>%2F2018%2F12%2F14%2FnewBolg%2F</url>
    <content type="text"><![CDATA[我的博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[filename]]></title>
    <url>%2F2018%2F12%2F13%2Ffilename%2F</url>
    <content type="text"><![CDATA[2.直线段的裁剪2.1 中线分割法2.2 Liang2.2.1 其他的]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
